# TCP

TCP（Transmission Control Protocol，传输控制协议）为应用提供一种可靠的、按序的、字节流服务。应用层字节流通过 TCP 报文段（TCP segments）在网络中传输，每个 TCP 报文段均以互联网协议（IP）数据报的形式发送。

+ 可靠性
  + 通过序列号检测数据包丢失；
  + 通过逐段校验和检测数据错误；
  + 通过重传机制纠正上述问题；

TCP 连接支持双向数据流传输，不过应用程序也可根据自身需求，仅选择单向发送数据。
  
  单向使用场景：应用层可通过关闭半连接（```shutdown(SHUT_WR)```）明确告知对方不再发送数据，仅保留接收能力（如服务器端处理完请求后，关闭写通道，仅读取客户端可能的后续数据）。


TCP 通过端口号识别应用层服务，并在主机间实现不同数据流的多路复用。

## 头格式

```
 0                   1                   2                   3
 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Source Port                 | Destination Port                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                    Sequence Number            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                             Acknowledgment Number             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Data  |       |C|E|U|A|P|R|S|F|                               |
 | Offset| Rsrvd |W|C|R|C|S|S|Y|I|           Window              |
 |       |       |R|E|G|K|H|T|N|N|                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Checksum                    | Urgent Pointer                  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                     [Options] |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               :
 :                                                   Data        :
 :                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

+ Source Port（源端口）

  16位字段，标识发送端的应用服务；

+ Destination Port（目的端口号）

  16位字段，标识接收端的目标应用服务；

+ Sequence Number（序号）

  32位字段，标识本分段中第一个数据字节的序号（SYN 标志置1时列外）：若 SYN = 1，该字段为初始序号，后续第一个数据字节序号为 ISN + 1；连接建立后用于保障数据有序传输和去重。

+ Acknowledgment Number（确认号）

  32位字段，仅当 ACK 标志置 1 时有效：（1）标识发送方期望接收的下一个序号（即已成功接收对方数据的最后一个序号 + 1）；（2）连接建立后，该字段必传（体现 TCP 的可靠确认机制）；

+ Data Offset(数据偏移量)

  4 位字段，单位为 32 位字（4字节），表示 TCP 头部的总长度：

  （1）计算公式：头部长度 = 数据偏移量 * 4 字节；

  （2）用于标识数据部分的起始位置

  （3）因头部可包含选项，长度不固定，但必须为 32 位的整数倍；、

+ Reserved（保留字段）

  4位字段，预留用于未来扩展。（1）发送方生成分段时必须置0；（2）接收方若未实现对应扩展功能，需忽略该字段的非零值；

+ CWR（拥塞窗口缩减标志）

  1 位标志，用于拥塞控制，标识发送方已收到接收方的拥塞通知并缩减拥塞窗口；

+ ECE（ECN 回显标志）

  1 位标志，与 ECN（显式拥塞通知）机制配合（详见 RFC 9293 对应章节），用于回显接收方检测到的网络拥塞状态。

+ URG（紧急指针有效标志）

  1 位标志，置 1 时表示 “紧急指针” 字段有效，通知接收方优先处理该分段中的紧急数据；

+ ACK（确认标志）

  1 位标志，置 1 时表示 “确认号” 字段有效（TCP 可靠传输的核心标志之一）

+ PSH（推送标志）

  1 位标志，触发 “推送功能”：（1） 发送方置 1 时，要求接收方立即将该分段的数据推送至应用层（而非缓存等待）；

+ RST（复位标志）

  1 位标志，用于强制重置 TCP 连接：（1）触发场景：接收方收到无效连接的分段、连接异常中断后恢复；

+ SYN（同步标志）
  
  1 位标志，用于 TCP 连接建立：（1）三次握手阶段，发起方发送 SYN=1 的分段，协商初始序号（ISN）；（2）仅在连接建立时置 1，数据传输阶段为 0；

+ FIN（终止标志）

  1 位标志，用于主动关闭 TCP 连接：（1）发送方置 1 表示无更多数据要发送，请求关闭连接；（2）需等待对方确认（FIN+ACK）后，连接进入半关闭状态；

+ Window（窗口大小）

  16位字段，标识接收方当前的接收缓冲区可用空间（单位：字节）：

  （1）用于 TCP 流量控制，避免发送方发送速率超过接收方处理能力；

  （2）接收方通过该字段动态告知发送方可发送的数据量；

+ Checksum（校验和）

  16 位字段，用于校验 TCP 头部 + 数据的完整性：

  （1）覆盖范围：TCP 伪头部（含 IP 源 / 目的地址、协议号）、TCP 头部、用户数据；

  （2）接收方校验失败则丢弃该分段，依赖重传机制保障可靠性。

+ Urget Pointer（紧急指针）

  16 位字段，仅当 URG=1 时有效：

  （1）表示从当前 “序号” 开始，到紧急数据结束的偏移量（即紧急数据的最后一个字节序号 = 当前序号 + 紧急指针 - 1）；

  （2）用于标记紧急数据范围（如中断信号、关键指令）；

+ Options（选项字段）

+ Data（数据部分）


## 序列号

  TCP 设计中的一个核心理念是：通过 TCP 连接传输的每个字节（octet） 都分配有一个序列号。由于每个字节都被编号排序，因此它们中的每一个都能被确认。TCP 采用的确认机制为累积确认（cumulative acknowledgment） —— 即确认号为 X 意味着，
所有序号小于 X（但不包含 X）的字节均已被接收方成功接收。该机制使得在存在重传的场景下，能够直接、简便地检测出重复数据。数据段（segment）内字节的编号规则如下：紧跟在 TCP 头部之后的第一个数据字节编号最小，后续字节按连续递增的方式依次编号。

高性能网络场景下的序列号循环周期，会短于基础 TCP 设计所考量的兆比特每秒（Mbps）级场景。在 1Gbps 速率下，序列号循环周期为 34 秒；10Gbps 速率下仅为 3 秒；而 100Gbps 速率下约为 1/3 秒。针对这些高性能场景，TCP 时间戳选项（TCP Timestamp Options）
与序列号回绕保护（PAWS，Protection Against Wrapped Sequences）机制，提供了检测并丢弃旧重复报文段的必要能力



### 初始化序列号选择

## 建立一个连接

“三次握手”是TCP建立连接的标准流程。该流程通常由一方 TCP 端点发起，另一方做出响应；即双方 TCP 端点同时发起连接（即“同时打开”场景），该流程依然有效。当同时打开时，每个 TCP 端点在发送 SYN 报文段后，会收到
一个未携带确认信息（ACK）的 SYN 报文段。需注意，旧连接的重复 SYN 报文段若延迟到达，可能会让接收方误以为正在发生同时打开，而合理使用 “复位”（RST）报文段可有效区分这类场景，消除歧义。

以下是几个连接建立的示例。尽管这些示例未展示使用 “携带数据的报文段” 进行连接同步的情况，但这种方式完全合法 —— 只要接收方 TCP 端点在确认数据有效前，不将数据交付给上层用户即可（例如，接收方会将数据缓存，
直至连接进入 ESTABLISHED 状态。毕竟三次握手已降低了虚假连接的可能性）。这种机制本质是在 “内存开销” 与 “用于校验的报文交互开销” 之间进行权衡。
  
图 6 展示了最简单的三次握手（3WHS）流程。图表的解读规则如下：
  
```
TCP Peer A                                             TCP Peer B
1. CLOSED                                              LISTEN
2. SYN-SENT --> <SEQ=100><CTL=SYN>                   --> SYN-RECEIVED
3. ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>   <-- SYN-RECEIVED
4. ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
5. ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

在图 6 的第 2 行中，TCP 端点 A 首先发送一个 SYN 报文段，表明其后续将使用以序列号 100 为起始的序列号空间；第 3 行中，TCP 端点 B 发送一个 SYN 报文段（同步自身序列号），同时对从 A 收到的 SYN 报文段进行确认。
需注意：确认号字段的值表明 B 当前期望接收的下一个序列号为 101—— 这一确认行为对应的是 A 发送的、占用了序列号 100 的 SYN 报文段（因 SYN 标志位虽不携带数据，但会占用 1 个序列号）。

在第 4 行中，TCP 端点 A 回复一个空报文段（无数据负载），其中包含对 TCP 端点 B 的 SYN 报文段的确认（ACK）；第 5 行中，TCP 端点 A 发送一段数据。需注意：第 5 行报文段的序列号与第 4 行相同 —— 因为 ACK 标志位
本身不占用序列号空间（若 ACK 占用序列号，则会导致 “确认号的确认” 这一逻辑循环，引发协议混乱）。

如图 7 所示，同时打开（Simultaneous Initiation）的流程仅略微复杂一些：每个 TCP 端点的连接状态均遵循 “CLOSED → SYN-SENT → SYN-RECEIVED → ESTABLISHED” 的循环路径演进。
```
TCP Peer A                                            TCP Peer B
1. CLOSED                                             CLOSED
2. SYN-SENT --> <SEQ=100><CTL=SYN>                    ...
3. SYN-RECEIVED <-- <SEQ=300><CTL=SYN>                <-- SYN-SENT
4. ... <SEQ=100><CTL=SYN>                             --> SYN-RECEIVED
5. SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK>   ...
6. ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>    <-- SYN-RECEIVED
7. ... <SEQ=100><ACK=301><CTL=SYN,ACK>                --> ESTABLISHED
```

TCP 协议实现必须支持同时打开尝试（强制要求第 10 条，MUST-10）。需注意：TCP 协议实现必须记录连接进入 SYN-RECEIVED 状态的原因 —— 是源于被动打开（passive OPEN）还是主动打开（active OPEN）（强制要求第 11 条，MUST-11）。

三次握手的核心目的是防止旧连接的重复连接请求引发混淆。为应对这一问题，TCP 协议定义了一种特殊的控制报文 —— 复位报文（reset，RST）。具体处理规则如下：

1. 若接收方 TCP 端点处于非同步状态（即 SYN-SENT、SYN-RECEIVED），收到合法的 RST 报文后，会恢复至 LISTEN 状态；

2. 若接收方处于同步状态（即 ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），收到 RST 报文后，会终止当前连接，并通知应用层用户。
下文将在 “半打开连接（half-open connections）” 部分详细讨论后一种情况。

```          ddddddddddddddddddddddddddd                                                                                               
TCP Peer A                                         TCP Peer B
1. CLOSED                                              LISTEN
2. SYN-SENT --> <SEQ=100><CTL=SYN>                                                                         ...
3. (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
4. SYN-SENT <-- <SEQ=300><ACK=91><CTL=SYN,ACK>     <-- SYN-RECEIVED
5. SYN-SENT --> <SEQ=91><CTL=RST>                  --> LISTEN
6. ... <SEQ=100><CTL=SYN>                          --> SYN-RECEIVED
7. ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
8. ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>     --> ESTABLISHED
```

第 3 行中，一个旧的重复 SYN 报文段到达 TCP 端点 B。由于 B 无法分辨该报文段是旧重复数据，因此按正常流程回复（第 4 行）；
TCP 端点 A 检测到 B 回复的 ACK 字段不正确，于是返回一个 RST（复位）报文段，且特意选择了合理的 SEQ 字段以确保该 RST 能被 B 认可；
B 收到 RST 后，恢复至 LISTEN 状态。当原始 SYN 报文段最终在第 6 行到达时，连接同步流程正常进行。若第 6 行的原始 SYN 早于 RST 到达 B
，则可能出现更复杂的交互 —— 双方会互相发送 RST 报文段。

## 半打开及其他异常场景

若 TCP 连接的一端已关闭或终止连接，但另一端毫不知情，或因故障、重启导致两端内存丢失进而造成连接状态不同步，则该已建立的连接被称为 “半打开连接（half-open connection）”。
此类连接若任何一方尝试发送数据，将自动触发复位（RST）机制。不过，半打开连接通常属于异常场景，并不常见。若端点 A 的连接已不存在（如已关闭或因重启丢失状态），而端点 B 的用
户仍尝试通过该连接发送数据，则端点 B 的 TCP 协议栈会收到一个复位（RST）控制报文。该报文会告知 B 的 TCP 协议栈 “连接存在异常”，B 需终止该连接。

假设用户进程 A 和 B 正在通信时，发生故障或重启导致 A 的 TCP 协议栈丢失内存（即丢失所有连接状态）。根据支撑 A 的 TCP 协议栈的操作系统特性，系统通常会存在某种错误恢复机制。
当 A 的 TCP 端点重新启动后，进程 A 可能会从头开始执行，或从某个恢复点恢复运行。因此，A 大概率会尝试重新建立（OPEN）该连接，或试图向其认为仍处于打开状态的连接发送（SEND）数据；
在后一种情况下，A 会从本地（A 的）TCP 协议栈收到 “连接未打开” 的错误提示（如 Linux 系统的ENOTCONN错误）。为建立连接，A 的 TCP 协议栈会发送一个携带 SYN 标志位的报文段。
该场景对应图 9 所示的示例：TCP 端点 A 重启后，用户尝试重新建立连接，而此时 TCP 端点 B 仍认为原连接处于打开状态。

```
TCP Peer A                                     TCP Peer B
 1. (REBOOT)                              (send 300,receive 100)
 2. CLOSED                                     ESTABLISHED
 3. SYN-SENT --> <SEQ=400><CTL=SYN>        --> (??)
 4. (!!) <-- <SEQ=300><ACK=100><CTL=ACK>   <-- ESTABLISHED
 5. SYN-SENT --> <SEQ=100><CTL=RST>        --> (Abort!!)
 6. SYN-SENT                                   CLOSED
 7. SYN-SENT --> <SEQ=400><CTL=SYN>        -->
```
当 SYN 报文段在第 3 行到达时，TCP 端点 B 正处于同步状态（已建立连接），且该入站报文段的序列号落在接收窗口之外，因此 B 回复一个确认报文段，指明其接下来期望接收的序列号（确认号为 100）。
TCP 端点 A 发现该确认报文段并未确认其发送的任何数据（A 刚重启，未发送过序列号 100 相关的数据），且自身处于非同步状态，因此检测到这是一个半打开连接，进而发送复位（RST）报文段。
TCP 端点 B 在第 5 行收到 RST 后终止原连接。之后 TCP 端点 A 会继续尝试建立连接，此时问题已简化为图 6 所示的基础三次握手流程。

另一种值得关注的情况是：TCP 端点 A 重启后，TCP 端点 B 仍试图向其认为处于同步状态的连接发送数据（如图 10 所示）。在该场景中，从 B 发送至 A 的数据流（第 2 行）因 A 侧不存在对应连接而被判定为无效，
因此 A 发送一个 RST 报文段。B 接收的 RST 报文段合法，故处理该报文并终止原连接。

```
TCP Peer A                                                TCP Peer B
1. (REBOOT)                                          (send 300,receive 100)
2. (??) <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK>        <-- ESTABLISHED
3.      --> <SEQ=100><CTL=RST>                          --> (ABORT!!)
```
图 10

图 11 描绘了两个 TCP 端点 A 和 B 均处于被动监听状态（等待 SYN 报文段）的场景。一个旧的重复报文段在第 2 行到达 TCP 端点 B，触发 B 的响应行为：B 返回一个 SYN-ACK 报文段（第 3 行），而该报文段导致 TCP 
端点 A 生成一个 RST（复位）报文段 —— 因第 3 行的确认号（ACK）对 A 而言是无效的。TCP 端点 B 接收并认可该 RST，随后恢复至被动监听（LISTEN）状态。
```
TCP Peer A                                         TCP Peer B
1. LISTEN                                          LISTEN
2. ... <SEQ=Z><CTL=SYN> --> SYN-RECEIVED
3. (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>     <-- SYN-RECEIVED
4. --> <SEQ=Z+1><CTL=RST>                     --> (return to LISTEN!)
5. LISTEN                                         LISTEN
```
图 11

TCP 协议还存在多种其他可能的异常场景，但所有场景均可通过以下关于复位（RST）报文段生成与处理的核心规则来覆盖（即所有异常均能通过这些规则解决）。

### 复位报文生成机制

TCP 用户或应用程序可在连接生命周期的任意时刻发起复位（RST）；此外，如后文所述，当各类错误条件发生时，TCP 协议本身也会自动生成复位事件。

发起复位的连接端应进入 TIME-WAIT 状态 —— 如前文所述，这一设计通常有助于减轻高负载服务器的压力。
核心规则如下：当收到的报文段明显不属于当前连接时，必须发送复位（RST）；若无法明确判定该报文段是否针对当前连接，则禁止发送 RST。

TCP 连接状态可分为三大类：

1. 若连接不存在（即处于 CLOSED 状态），则接收方会对所有入站报文段（除其他复位报文 RST 外）回复一个复位报文（RST）。通过这种方式，可拒绝任何与现有连接不匹配的 SYN 报文段（即无对应监听端口或无匹配连接的 SYN 请求）。

   若入站报文段设置了 ACK 标志位，则复位报文（RST）的序列号取自该报文段的 ACK 字段；否则，RST 的序列号设为 0，且其 ACK 字段设为入站报文段的序列号与报文段长度之和。连接始终保持 CLOSED 状态。

2. 若连接处于任一非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），且入站报文段确认了未发送的数据（即携带无效 ACK），或入站报文段的安全级别 / 隔离域（见附录 A.1）与连接请求的安全级别 / 隔离域不完全匹配，则发送 RST。

   若入站报文段设置了 ACK 标志位，则 RST 的序列号取自该报文段的 ACK 字段；否则，RST 的序列号设为 0，且其 ACK 字段设为入站报文段的序列号与报文段长度之和。连接保持原状态不变。

3. 若连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），则任何无效报文段（序列号落在窗口外或确认号无效）都必须以空确认报文段（无用户数据）响应 —— 该确认报文段包含当前发送序列号和期望接收的下一个序列号，连接保持原状态不变。

   若入站报文段的安全级别 / 隔离域与连接请求的安全级别 / 隔离域不完全匹配，则发送 RST 并将连接置为 CLOSED 状态。RST 的序列号取自入站报文段的 ACK 字段。

### 复位报文处理

除 SYN-SENT 状态外，所有状态下收到的复位（RST）报文段都需通过校验其序列号（SEQ 字段）验证合法性：若 RST 的序列号落在当前接收窗口内，则判定为合法。处于 SYN-SENT 状态时（收到针对初始 SYN 的 RST 响应），若 RST 的确认号（ACK 字段）能确认该 SYN（即 ACK 字段等于 SYN 的序列号 + 1），则该 RST 可被接受。
RST 的接收方需先验证其合法性，再执行状态变迁：
1. 若接收方处于 LISTEN 状态，直接忽略该 RST；

3. 若接收方处于 SYN-RECEIVED 状态，且此前处于 LISTEN 状态（被动打开场景），则恢复至 LISTEN 状态；否则（主动打开场景，如同时打开），终止连接并进入 CLOSED 状态；
   
5. 若接收方处于其他任何状态，终止连接、通知应用层用户，并进入 CLOSED 状态。
   
TCP 协议实现允许接收的 RST 报文段携带数据（建议性要求第 2 条，SHLD-2）。有观点认为，RST 可包含诊断数据以说明复位原因，但目前尚未针对此类数据制定统一标准。

## 关闭连接





