# TCP

TCP（Transmission Control Protocol，传输控制协议）为应用提供一种可靠的、按序的、字节流服务。应用层字节流通过 TCP 报文段（TCP segments）在网络中传输，每个 TCP 报文段均以互联网协议（IP）数据报的形式发送。

+ 可靠性
  + 通过序列号检测数据包丢失；
  + 通过逐段校验和检测数据错误；
  + 通过重传机制纠正上述问题；

TCP 连接支持双向数据流传输，不过应用程序也可根据自身需求，仅选择单向发送数据。
  
  单向使用场景：应用层可通过关闭半连接（```shutdown(SHUT_WR)```）明确告知对方不再发送数据，仅保留接收能力（如服务器端处理完请求后，关闭写通道，仅读取客户端可能的后续数据）。


TCP 通过端口号识别应用层服务，并在主机间实现不同数据流的多路复用。

## 头格式

```
 0                   1                   2                   3
 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Source Port                 | Destination Port                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                    Sequence Number            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                             Acknowledgment Number             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Data  |       |C|E|U|A|P|R|S|F|                               |
 | Offset| Rsrvd |W|C|R|C|S|S|Y|I|           Window              |
 |       |       |R|E|G|K|H|T|N|N|                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Checksum                    | Urgent Pointer                  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                     [Options] |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               :
 :                                                   Data        :
 :                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

+ Source Port（源端口）

  16位字段，标识发送端的应用服务；

+ Destination Port（目的端口号）

  16位字段，标识接收端的目标应用服务；

+ Sequence Number（序号）

  32位字段，标识本分段中第一个数据字节的序号（SYN 标志置1时列外）：若 SYN = 1，该字段为初始序号，后续第一个数据字节序号为 ISN + 1；连接建立后用于保障数据有序传输和去重。

+ Acknowledgment Number（确认号）

  32位字段，仅当 ACK 标志置 1 时有效：（1）标识发送方期望接收的下一个序号（即已成功接收对方数据的最后一个序号 + 1）；（2）连接建立后，该字段必传（体现 TCP 的可靠确认机制）；

+ Data Offset(数据偏移量)

  4 位字段，单位为 32 位字（4字节），表示 TCP 头部的总长度：

  （1）计算公式：头部长度 = 数据偏移量 * 4 字节；

  （2）用于标识数据部分的起始位置

  （3）因头部可包含选项，长度不固定，但必须为 32 位的整数倍；、

+ Reserved（保留字段）

  4位字段，预留用于未来扩展。（1）发送方生成分段时必须置0；（2）接收方若未实现对应扩展功能，需忽略该字段的非零值；

+ CWR（拥塞窗口缩减标志）

  1 位标志，用于拥塞控制，标识发送方已收到接收方的拥塞通知并缩减拥塞窗口；

+ ECE（ECN 回显标志）

  1 位标志，与 ECN（显式拥塞通知）机制配合（详见 RFC 9293 对应章节），用于回显接收方检测到的网络拥塞状态。

+ URG（紧急指针有效标志）

  1 位标志，置 1 时表示 “紧急指针” 字段有效，通知接收方优先处理该分段中的紧急数据；

+ ACK（确认标志）

  1 位标志，置 1 时表示 “确认号” 字段有效（TCP 可靠传输的核心标志之一）

+ PSH（推送标志）

  1 位标志，触发 “推送功能”：（1） 发送方置 1 时，要求接收方立即将该分段的数据推送至应用层（而非缓存等待）；

+ RST（复位标志）

  1 位标志，用于强制重置 TCP 连接：（1）触发场景：接收方收到无效连接的分段、连接异常中断后恢复；

+ SYN（同步标志）
  
  1 位标志，用于 TCP 连接建立：（1）三次握手阶段，发起方发送 SYN=1 的分段，协商初始序号（ISN）；（2）仅在连接建立时置 1，数据传输阶段为 0；

+ FIN（终止标志）

  1 位标志，用于主动关闭 TCP 连接：（1）发送方置 1 表示无更多数据要发送，请求关闭连接；（2）需等待对方确认（FIN+ACK）后，连接进入半关闭状态；

+ Window（窗口大小）

  16位字段，标识接收方当前的接收缓冲区可用空间（单位：字节）：

  （1）用于 TCP 流量控制，避免发送方发送速率超过接收方处理能力；

  （2）接收方通过该字段动态告知发送方可发送的数据量；

+ Checksum（校验和）

  16 位字段，用于校验 TCP 头部 + 数据的完整性：

  （1）覆盖范围：TCP 伪头部（含 IP 源 / 目的地址、协议号）、TCP 头部、用户数据；

  （2）接收方校验失败则丢弃该分段，依赖重传机制保障可靠性。

+ Urget Pointer（紧急指针）

  16 位字段，仅当 URG=1 时有效：

  （1）表示从当前 “序号” 开始，到紧急数据结束的偏移量（即紧急数据的最后一个字节序号 = 当前序号 + 紧急指针 - 1）；

  （2）用于标记紧急数据范围（如中断信号、关键指令）；

+ Options（选项字段）

+ Data（数据部分）


## 序列号

  TCP 设计中的一个核心理念是：通过 TCP 连接传输的每个字节（octet） 都分配有一个序列号。由于每个字节都被编号排序，因此它们中的每一个都能被确认。TCP 采用的确认机制为累积确认（cumulative acknowledgment） —— 即确认号为 X 意味着，
所有序号小于 X（但不包含 X）的字节均已被接收方成功接收。该机制使得在存在重传的场景下，能够直接、简便地检测出重复数据。数据段（segment）内字节的编号规则如下：紧跟在 TCP 头部之后的第一个数据字节编号最小，后续字节按连续递增的方式依次编号。

高性能网络场景下的序列号循环周期，会短于基础 TCP 设计所考量的兆比特每秒（Mbps）级场景。在 1Gbps 速率下，序列号循环周期为 34 秒；10Gbps 速率下仅为 3 秒；而 100Gbps 速率下约为 1/3 秒。针对这些高性能场景，TCP 时间戳选项（TCP Timestamp Options）
与序列号回绕保护（PAWS，Protection Against Wrapped Sequences）机制，提供了检测并丢弃旧重复报文段的必要能力



### 初始化序列号选择

## 建立一个连接

“三次握手”是TCP建立连接的标准流程。该流程通常由一方 TCP 端点发起，另一方做出响应；即双方 TCP 端点同时发起连接（即“同时打开”场景），该流程依然有效。当同时打开时，每个 TCP 端点在发送 SYN 报文段后，会收到
一个未携带确认信息（ACK）的 SYN 报文段。需注意，旧连接的重复 SYN 报文段若延迟到达，可能会让接收方误以为正在发生同时打开，而合理使用 “复位”（RST）报文段可有效区分这类场景，消除歧义。

以下是几个连接建立的示例。尽管这些示例未展示使用 “携带数据的报文段” 进行连接同步的情况，但这种方式完全合法 —— 只要接收方 TCP 端点在确认数据有效前，不将数据交付给上层用户即可（例如，接收方会将数据缓存，
直至连接进入 ESTABLISHED 状态。毕竟三次握手已降低了虚假连接的可能性）。这种机制本质是在 “内存开销” 与 “用于校验的报文交互开销” 之间进行权衡。
  
图 6 展示了最简单的三次握手（3WHS）流程。图表的解读规则如下：
  
```
TCP Peer A                                             TCP Peer B
1. CLOSED                                              LISTEN
2. SYN-SENT --> <SEQ=100><CTL=SYN>                   --> SYN-RECEIVED
3. ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>   <-- SYN-RECEIVED
4. ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
5. ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

在图 6 的第 2 行中，TCP 端点 A 首先发送一个 SYN 报文段，表明其后续将使用以序列号 100 为起始的序列号空间；第 3 行中，TCP 端点 B 发送一个 SYN 报文段（同步自身序列号），同时对从 A 收到的 SYN 报文段进行确认。
需注意：确认号字段的值表明 B 当前期望接收的下一个序列号为 101—— 这一确认行为对应的是 A 发送的、占用了序列号 100 的 SYN 报文段（因 SYN 标志位虽不携带数据，但会占用 1 个序列号）。

在第 4 行中，TCP 端点 A 回复一个空报文段（无数据负载），其中包含对 TCP 端点 B 的 SYN 报文段的确认（ACK）；第 5 行中，TCP 端点 A 发送一段数据。需注意：第 5 行报文段的序列号与第 4 行相同 —— 因为 ACK 标志位
本身不占用序列号空间（若 ACK 占用序列号，则会导致 “确认号的确认” 这一逻辑循环，引发协议混乱）。

如图 7 所示，同时打开（Simultaneous Initiation）的流程仅略微复杂一些：每个 TCP 端点的连接状态均遵循 “CLOSED → SYN-SENT → SYN-RECEIVED → ESTABLISHED” 的循环路径演进。
```
TCP Peer A                                            TCP Peer B
1. CLOSED                                             CLOSED
2. SYN-SENT --> <SEQ=100><CTL=SYN>                    ...
3. SYN-RECEIVED <-- <SEQ=300><CTL=SYN>                <-- SYN-SENT
4. ... <SEQ=100><CTL=SYN>                             --> SYN-RECEIVED
5. SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK>   ...
6. ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>    <-- SYN-RECEIVED
7. ... <SEQ=100><ACK=301><CTL=SYN,ACK>                --> ESTABLISHED
```

TCP 协议实现必须支持同时打开尝试（强制要求第 10 条，MUST-10）。需注意：TCP 协议实现必须记录连接进入 SYN-RECEIVED 状态的原因 —— 是源于被动打开（passive OPEN）还是主动打开（active OPEN）（强制要求第 11 条，MUST-11）。

三次握手的核心目的是防止旧连接的重复连接请求引发混淆。为应对这一问题，TCP 协议定义了一种特殊的控制报文 —— 复位报文（reset，RST）。具体处理规则如下：

1. 若接收方 TCP 端点处于非同步状态（即 SYN-SENT、SYN-RECEIVED），收到合法的 RST 报文后，会恢复至 LISTEN 状态；

2. 若接收方处于同步状态（即 ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），收到 RST 报文后，会终止当前连接，并通知应用层用户。
下文将在 “半打开连接（half-open connections）” 部分详细讨论后一种情况。

```          ddddddddddddddddddddddddddd                                                                                               
TCP Peer A                                         TCP Peer B
1. CLOSED                                              LISTEN
2. SYN-SENT --> <SEQ=100><CTL=SYN>                                                                         ...
3. (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED
4. SYN-SENT <-- <SEQ=300><ACK=91><CTL=SYN,ACK>     <-- SYN-RECEIVED
5. SYN-SENT --> <SEQ=91><CTL=RST>                  --> LISTEN
6. ... <SEQ=100><CTL=SYN>                          --> SYN-RECEIVED
7. ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
8. ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>     --> ESTABLISHED
```

第 3 行中，一个旧的重复 SYN 报文段到达 TCP 端点 B。由于 B 无法分辨该报文段是旧重复数据，因此按正常流程回复（第 4 行）；
TCP 端点 A 检测到 B 回复的 ACK 字段不正确，于是返回一个 RST（复位）报文段，且特意选择了合理的 SEQ 字段以确保该 RST 能被 B 认可；
B 收到 RST 后，恢复至 LISTEN 状态。当原始 SYN 报文段最终在第 6 行到达时，连接同步流程正常进行。若第 6 行的原始 SYN 早于 RST 到达 B
，则可能出现更复杂的交互 —— 双方会互相发送 RST 报文段。

## 半打开及其他异常场景

若 TCP 连接的一端已关闭或终止连接，但另一端毫不知情，或因故障、重启导致两端内存丢失进而造成连接状态不同步，则该已建立的连接被称为 “半打开连接（half-open connection）”。
此类连接若任何一方尝试发送数据，将自动触发复位（RST）机制。不过，半打开连接通常属于异常场景，并不常见。若端点 A 的连接已不存在（如已关闭或因重启丢失状态），而端点 B 的用
户仍尝试通过该连接发送数据，则端点 B 的 TCP 协议栈会收到一个复位（RST）控制报文。该报文会告知 B 的 TCP 协议栈 “连接存在异常”，B 需终止该连接。

假设用户进程 A 和 B 正在通信时，发生故障或重启导致 A 的 TCP 协议栈丢失内存（即丢失所有连接状态）。根据支撑 A 的 TCP 协议栈的操作系统特性，系统通常会存在某种错误恢复机制。
当 A 的 TCP 端点重新启动后，进程 A 可能会从头开始执行，或从某个恢复点恢复运行。因此，A 大概率会尝试重新建立（OPEN）该连接，或试图向其认为仍处于打开状态的连接发送（SEND）数据；
在后一种情况下，A 会从本地（A 的）TCP 协议栈收到 “连接未打开” 的错误提示（如 Linux 系统的ENOTCONN错误）。为建立连接，A 的 TCP 协议栈会发送一个携带 SYN 标志位的报文段。
该场景对应图 9 所示的示例：TCP 端点 A 重启后，用户尝试重新建立连接，而此时 TCP 端点 B 仍认为原连接处于打开状态。

```
TCP Peer A                                     TCP Peer B
 1. (REBOOT)                              (send 300,receive 100)
 2. CLOSED                                     ESTABLISHED
 3. SYN-SENT --> <SEQ=400><CTL=SYN>        --> (??)
 4. (!!) <-- <SEQ=300><ACK=100><CTL=ACK>   <-- ESTABLISHED
 5. SYN-SENT --> <SEQ=100><CTL=RST>        --> (Abort!!)
 6. SYN-SENT                                   CLOSED
 7. SYN-SENT --> <SEQ=400><CTL=SYN>        -->
```
当 SYN 报文段在第 3 行到达时，TCP 端点 B 正处于同步状态（已建立连接），且该入站报文段的序列号落在接收窗口之外，因此 B 回复一个确认报文段，指明其接下来期望接收的序列号（确认号为 100）。
TCP 端点 A 发现该确认报文段并未确认其发送的任何数据（A 刚重启，未发送过序列号 100 相关的数据），且自身处于非同步状态，因此检测到这是一个半打开连接，进而发送复位（RST）报文段。
TCP 端点 B 在第 5 行收到 RST 后终止原连接。之后 TCP 端点 A 会继续尝试建立连接，此时问题已简化为图 6 所示的基础三次握手流程。

另一种值得关注的情况是：TCP 端点 A 重启后，TCP 端点 B 仍试图向其认为处于同步状态的连接发送数据（如图 10 所示）。在该场景中，从 B 发送至 A 的数据流（第 2 行）因 A 侧不存在对应连接而被判定为无效，
因此 A 发送一个 RST 报文段。B 接收的 RST 报文段合法，故处理该报文并终止原连接。

```
TCP Peer A                                                TCP Peer B
1. (REBOOT)                                          (send 300,receive 100)
2. (??) <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK>        <-- ESTABLISHED
3.      --> <SEQ=100><CTL=RST>                          --> (ABORT!!)
```
图 10

图 11 描绘了两个 TCP 端点 A 和 B 均处于被动监听状态（等待 SYN 报文段）的场景。一个旧的重复报文段在第 2 行到达 TCP 端点 B，触发 B 的响应行为：B 返回一个 SYN-ACK 报文段（第 3 行），而该报文段导致 TCP 
端点 A 生成一个 RST（复位）报文段 —— 因第 3 行的确认号（ACK）对 A 而言是无效的。TCP 端点 B 接收并认可该 RST，随后恢复至被动监听（LISTEN）状态。
```
TCP Peer A                                         TCP Peer B
1. LISTEN                                          LISTEN
2. ... <SEQ=Z><CTL=SYN> --> SYN-RECEIVED
3. (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>     <-- SYN-RECEIVED
4. --> <SEQ=Z+1><CTL=RST>                     --> (return to LISTEN!)
5. LISTEN                                         LISTEN
```
图 11

TCP 协议还存在多种其他可能的异常场景，但所有场景均可通过以下关于复位（RST）报文段生成与处理的核心规则来覆盖（即所有异常均能通过这些规则解决）。

### 复位报文生成机制

TCP 用户或应用程序可在连接生命周期的任意时刻发起复位（RST）；此外，如后文所述，当各类错误条件发生时，TCP 协议本身也会自动生成复位事件。

发起复位的连接端应进入 TIME-WAIT 状态 —— 如前文所述，这一设计通常有助于减轻高负载服务器的压力。
核心规则如下：当收到的报文段明显不属于当前连接时，必须发送复位（RST）；若无法明确判定该报文段是否针对当前连接，则禁止发送 RST。

TCP 连接状态可分为三大类：

1. 若连接不存在（即处于 CLOSED 状态），则接收方会对所有入站报文段（除其他复位报文 RST 外）回复一个复位报文（RST）。通过这种方式，可拒绝任何与现有连接不匹配的 SYN 报文段（即无对应监听端口或无匹配连接的 SYN 请求）。

   若入站报文段设置了 ACK 标志位，则复位报文（RST）的序列号取自该报文段的 ACK 字段；否则，RST 的序列号设为 0，且其 ACK 字段设为入站报文段的序列号与报文段长度之和。连接始终保持 CLOSED 状态。

2. 若连接处于任一非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），且入站报文段确认了未发送的数据（即携带无效 ACK），或入站报文段的安全级别 / 隔离域（见附录 A.1）与连接请求的安全级别 / 隔离域不完全匹配，则发送 RST。

   若入站报文段设置了 ACK 标志位，则 RST 的序列号取自该报文段的 ACK 字段；否则，RST 的序列号设为 0，且其 ACK 字段设为入站报文段的序列号与报文段长度之和。连接保持原状态不变。

3. 若连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），则任何无效报文段（序列号落在窗口外或确认号无效）都必须以空确认报文段（无用户数据）响应 —— 该确认报文段包含当前发送序列号和期望接收的下一个序列号，连接保持原状态不变。

   若入站报文段的安全级别 / 隔离域与连接请求的安全级别 / 隔离域不完全匹配，则发送 RST 并将连接置为 CLOSED 状态。RST 的序列号取自入站报文段的 ACK 字段。

### 复位报文处理

除 SYN-SENT 状态外，所有状态下收到的复位（RST）报文段都需通过校验其序列号（SEQ 字段）验证合法性：若 RST 的序列号落在当前接收窗口内，则判定为合法。处于 SYN-SENT 状态时（收到针对初始 SYN 的 RST 响应），若 RST 的确认号（ACK 字段）能确认该 SYN（即 ACK 字段等于 SYN 的序列号 + 1），则该 RST 可被接受。
RST 的接收方需先验证其合法性，再执行状态变迁：
1. 若接收方处于 LISTEN 状态，直接忽略该 RST；

3. 若接收方处于 SYN-RECEIVED 状态，且此前处于 LISTEN 状态（被动打开场景），则恢复至 LISTEN 状态；否则（主动打开场景，如同时打开），终止连接并进入 CLOSED 状态；
   
5. 若接收方处于其他任何状态，终止连接、通知应用层用户，并进入 CLOSED 状态。
   
TCP 协议实现允许接收的 RST 报文段携带数据（建议性要求第 2 条，SHLD-2）。有观点认为，RST 可包含诊断数据以说明复位原因，但目前尚未针对此类数据制定统一标准。

## 关闭连接

CLOSE（关闭）是一种操作，表示 “我已无更多数据要发送”。当然，关闭全双工（full-duplex）连接的概念本身存在歧义，因为如何处理连接的接收端并不明确。对此，我们选择以单工方式处理 CLOSE 操作：

执行 CLOSE 的一方仍可继续接收数据（RECEIVE），直到 TCP 接收端被告知对端（remote peer）也已执行 CLOSE。因此，程序可以先执行多次发送操作（SEND），随后发起 CLOSE，之后继续接收数据，
直到收到 “接收失败” 的通知 —— 这一通知表明对端已关闭连接。

即使当前没有未完成的接收请求（outstanding RECEIVEs），TCP 实现也会向用户发出 “对端已关闭连接” 的信号，以便用户优雅地终止本方连接。此外，TCP 实现会可靠地交付所有在连接关闭前发送的缓
冲区数据（SENT buffers），因此，若用户无需接收返回数据，只需等待连接 “关闭成功” 的确认，即可确认所有数据已送达目标 TCP 端点。注意：用户关闭发送端后，必须持续读取该连接的数据，直到 TCP 实现提示 “无更多数据” 为止。

本质上存在三种情况：

1. 用户首先通知 TCP 实现关闭连接（即图 12 中的 TCP 端 A）;
2. 对端 TCP 端点主动发送 FIN 控制信号以发起（关闭操作）（即图 12 中的 TCP 端 B）;
3. 双方用户同时发起 CLOSE 操作（见图 13）;

场景一：

在此场景下，TCP 会构造一个 FIN 报文段并放入发送队列。TCP 实现将不再接受用户后续发起的任何 SEND（发送）操作，并进入FIN-WAIT-1 状态。该状态下允许执行 RECEIVE（接收）操作。
所有在 FIN 之前（含 FIN 本身）的报文段，都会重传直至收到确认（ACK）。当对端 TCP 已确认（ACK）本方 FIN，且自身也发送了 FIN 报文段后，本方 TCP 即可对该 FIN 进行确认（ACK）。
需注意：TCP 端点收到 FIN 后会立即发送确认（ACK），但仅在其用户也执行了 CLOSE（关闭）操作后，才会发送自身的 FIN 报文段。

场景二：

若网络中收到未经请求的 FIN 报文段（unsolicited FIN），接收方 TCP 端点会对其进行确认（ACK），并通知用户 “连接正在关闭”。用户会响应一个 CLOSE 操作，此后 TCP 端点会先发送所有剩余数据，
再向对端 TCP 发送 FIN 报文段。随后，该 TCP 端点会等待自身 FIN 被确认，一旦确认完成便删除该连接；若迟迟未收到确认（ACK），则在用户超时（user timeout）后终止（abort）连接，并将该情况通知用户。

场景三：

连接两端的用户同时发起 CLOSE 操作时，会触发双方交换 FIN 报文段（见图 13）。当所有位于 FIN 报文段之前的报文段均已被处理并确认后，每一方 TCP 对等端都会对收到的 FIN 进行确认。双方在各自收到该确认（ACK）后，便会删除该连接。

```
TCP Peer A                                             TCP Peer B
1. ESTABLISHED ESTABLISHED
2. (Close)
   FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK> --> CLOSE-WAIT
3. FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>     <-- CLOSE-WAIT
4.                                                     (Close)
   TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK> <-- LAST-ACK
5. TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>     --> CLOSED
6. (2 MSL)
   CLOSED

                 图 12 - 正常关闭流程
```

```
TCP Peer                                                   A TCP Peer B
1. ESTABLISHED                                             ESTABLISHED
2. (Close)                                                 (Close)
   FIN-WAIT-1    --> <SEQ=100><ACK=300><CTL=FIN,ACK>   ... FIN-WAIT-1
                 <-- <SEQ=300><ACK=100><CTL=FIN,ACK>   <--
                 ... <SEQ=100><ACK=300><CTL=FIN,ACK>   -->
3. CLOSING       --> <SEQ=101><ACK=301><CTL=ACK> ...       CLOSING
                 <-- <SEQ=301><ACK=101><CTL=ACK> <--
                 ... <SEQ=101><ACK=301><CTL=ACK> -->
4. TIME-WAIT                                               TIME-WAIT
 (2 MSL)                                                   (2 MSL)
 CLOSED                                                    CLOSED
               图 13 同时关闭流程
```

TCP 连接的终止方式有两种：

（1）通过 FIN 握手执行的 TCP 正常关闭流程（见图 12）；

（2）“终止（abort）” 方式 —— 即发送一个或多个 RST 报文段，并立即丢弃连接状态。若本地 TCP 连接因收到对端发送的 FIN 或 RST 而被对端关闭，则必须通知本地应用程序该连接是正常关闭还是被强制终止（MUST-12）

### 半关闭连接

TCP 正常关闭流程会可靠地交付双向缓冲区中的数据。由于 TCP 连接的两个通信方向是独立关闭的，因此连接可能处于 “半关闭（half-closed）” 状态 —— 即仅在一个方向上关闭；而在半关闭连接中，主机可继续在未关闭的方向上发送数据。


主机可实现 “半双工（half-duplex）”TCP 关闭流程，即调用 CLOSE 操作的应用程序无法再从该连接读取数据（MAY-1）。若此类主机在 TCP 连接中仍有待接收数据（received data pending）时发起 CLOSE 调用，
或在调用 CLOSE 后收到新数据，则其 TCP 实现应发送 RST 报文段，以表明数据已丢失（SHLD-3）。相关讨论参见 。

当连接被主动关闭时，它会在TIME-WAIT 状态中停留2 倍最大报文段生存期（2×MSL，Maximum Segment Lifetime） 的时长（MUST-13）。不过，若满足以下条件，
该 TCP 端点可从 TIME-WAIT 状态直接接收对端 TCP 发来的新 SYN 报文段，以重新建立连接（MAY-2）：

（1）为新连接分配的初始序列号（initial sequence number），需大于其在先前连接实例（previous connection incarnation） 中使用过的最大序列号；

（2）若该 SYN 报文段经判定为旧重复报文段（old duplicate） ，则需返回 TIME-WAIT 状态；

当 TCP 时间戳选项（TCP Timestamp Options）可用时，[参考文献标注，原文 “in” 后缺失具体文献标识] 中描述了一种改进算法，以支持更高的连接建立速率。这种用于缩短 TIME-WAIT 状态时长的算法是当前的最佳实践（Best Current Practice），
建议予以实现—— 因为时间戳选项已被广泛使用，且借助该选项缩短 TIME-WAIT 状态时长，能为高负载的互联网服务器带来显著收益（SHLD-4）。


## 分段

“分段（segmentation）” 指 TCP 的一项核心操作：从发送方应用程序接收字节流，并将其打包为 TCP 报文段（TCP segments）。单个 TCP 报文段通常与应用程序发起的单次发送（或套接字写入，socket write）调用并非一一对应。
应用程序可能会按照上层协议的 “消息（message）” 粒度执行写入操作，但 TCP 并不保证发送 / 接收的 TCP 报文段边界，与用户应用程序数据的读写缓冲区边界存在任何关联。

在部分特定协议中（例如采用直接数据放置（DDP，Direct Data Placement）和标记 PDU 对齐成帧（MPA，Marker PDU Aligned Framing）的远程直接内存访问（RDMA，Remote Direct Memory Access）），
若能控制 TCP 报文段与应用数据单元（application data units）之间的对应关系，可实现性能优化；且 MPA 协议包含专门的机制，用于检测和验证 TCP 报文段与应用层消息数据结构之间的这种对应关系 —— 但这仅适用于 RDMA 等特定应用场景。

总体而言，TCP 实现创建 TCP 报文段时的尺寸选择，会受到多重目标的影响。

驱动 TCP 发送更大尺寸报文段的核心目标包括：
+ 减少网络中传输的在途数据包数量；
+ 减少中断次数和层间交互操作，从而提升处理效率并优化潜在性能；
+ 控制 TCP 报头的开销。

需注意的是，发送更大尺寸报文段所带来的性能收益，会随着报文段尺寸的增大而逐渐递减；并且在某些临界尺寸点，其优势可能会反向转化（即出现性能衰退）。例如，在部分实现架构中，一个报文段承载 1025 字节的数据，
可能会比承载 1024 字节时性能更差 —— 这纯粹是由于复制操作中的数据对齐（data alignment）问题导致的。

驱动 TCP 发送更小尺寸报文段的核心目标包括：

+ 避免发送会导致 IP 数据报（IP datagram）超出 IP 网络路径上最小 MTU（最大传输单元，Maximum Transmission Unit） 的 TCP 报文段 —— 因为这会引发数据包丢失或 IP 分片（packet fragmentation）；
  更严重的是，部分防火墙或中间设备（middleboxes）可能会丢弃分片数据包，或与分片相关的 ICMP 消息（如分片需要、分片失败通知等）。
+ 避免应用程序数据流出现延迟，尤其当 TCP 在等待应用程序生成更多数据时，或应用程序需等待某个事件发生、或等待对端的输入后才能生成更多数据时。
+ 实现 TCP 报文段与下层数据单元的 “命运共享（fate sharing）”（例如，对于 IP 层之下、信元或帧尺寸小于 IP MTU 的链路，使 TCP 报文段与下层数据单元绑定传输）。

为平衡上述相互竞争的多组目标，TCP 包含多种机制，包括最大报文段尺寸选项（Maximum Segment Size Option，MSS 选项）、路径 MTU 发现（Path MTU Discovery，PMTU Discovery）、
纳格尔算法（Nagle algorithm）以及对 IPv6 巨型数据报（IPv6 Jumbograms）的支持 —— 相关细节将在后续小节中讨论。

### 最大分段大小选项

TCP 端点必须实现最大报文段尺寸选项（MSS Option）的发送与接收功能。

TCP 实现需在以下场景发送最大报文段尺寸选项（MSS Option）：

1. 建议性要求（SHLD-5）：当自身接收 MSS（接收最大报文段尺寸）与默认值（IPv4 为 536 字节、IPv6 为 1220 字节）不一致时，需在每个 SYN 报文段中携带 MSS 选项；

2. 可选要求（MAY-3）：也可选择在所有 SYN 报文段中始终携带 MSS 选项；

若在连接建立阶段未收到最大报文段尺寸选项（MSS Option），TCP 实现必须采用默认发送 MSS 值：IPv4 环境下为 536 字节（计算方式：576 - 40），IPv6 环境下为 1220 字节（计算方式：1280 - 60）（MUST-15）。

TCP 端点实际发送的报文段最大尺寸（即 “有效发送 MSS（effective send MSS）”），必须取以下两个值中的较小值（MUST-16）：

1. 发送 MSS（该值反映对端主机的可用重组缓冲区大小，即 EMTU_R）；

2. IP 层允许的最大传输尺寸（即 EMTU_S）。

Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize

其中：

+ 发送 MSS（SendMSS）的取值规则为：若从对端主机收到 MSS 选项值，则采用该值；若未收到 MSS 选项，则 IPv4 环境下默认取值 536 字节，IPv6 环境下默认取值 1220 字节；

+ MMS_S：传输层消息的最大长度，即 TCP 可发送的传输层消息的最大尺寸。

+ TCPhdrsize（TCP 报头长度）：指固定 TCP 报头与所有选项的总长度。在（罕见的）无选项场景下，该值为 20 字节；若需携带 TCP 选项，则长度可能更大。需注意：部分选项并非所有数据段（segment）都会包含，但对于每个发送的数据段，发送方应在有效发送 MSS（Eff.snd.MSS） 范围内，相应调整数据部分的长度。

+ IPoptionsize（IP 选项长度）：指与 TCP 连接相关的所有 IPv4 选项或 IPv6 扩展报头的总长度。需注意：部分选项或扩展报头并非所有数据包（packet）都会包含，但对于每个发送的数据段，发送方应在有效发送 MSS（Eff.snd.MSS） 范围内，相应调整数据部分的长度。

在 MSS 选项（MSS Option）中携带的 MSS 值，应等于有效最大传输单元（effective MTU） 减去固定 IP 报头与固定 TCP 报头的长度之和。由于计算 MSS 选项值时会忽略所有 IP 选项和 TCP 选项，因此若某个数据包需携带 IP 选项或 TCP 选项，
发送方必须相应减小 TCP 数据部分的长度。RFC 6691 对该机制有更详细的说明。

在 MSS 选项（MSS Option）中携带的 MSS 值，必须小于或等于以下数值：

MMS_R - 20

其中，MMS_R 指接收方可接收（并在 IP 层重组）的传输层消息最大尺寸（参见强制要求 MUST-67）。TCP 从 IP 层获取 MMS_R 和前文提及的 MMS_S；具体可参考 RFC 1122 第 3.4 节中通用调用 GET_MAXSIZES 的定义。
这两个参数（MMS_R、MMS_S）基于其对应的 IP MTU 等效值 ——EMTU_R（接收方等效 MTU）和 EMTU_S（发送方等效 MTU）来定义。

若 TCP 运行在 IP 报头或 TCP 报头长度不固定的场景下（即可能携带选项时），发送方必须根据 IP 选项和 TCP 选项占用的字节数，相应减少每个数据包中的 TCP 数据量。如 RFC 6691 第 3.1 节所述，这一点在历史上曾引发诸多误解。

### 路径 MUT 发现

TCP 实现可能会知晓直连链路的最大传输单元（MTU），但通常无法了解整个网络路径中的 MTU 情况。对于 IPv4，RFC 1122 建议，针对非直连目的地，IP 层的默认有效 MTU 应小于或等于 576 字节；而 IPv6 的这一默认值为 1280 字节。
使用这些固定值会限制 TCP 连接的性能和效率。因此，强烈建议实现路径 MTU 发现（PMTUD）和分组层路径 MTU 发现（PLPMTUD），使 TCP 能优化分段决策。PMTUD 和 PLPMTUD 均有助于 TCP 选择合适的分段大小，从而避免路径上的分片（针对 IPv4）和源端分片（针对 IPv4 和 IPv6）。

IPv4 或 IPv6 版本的 PMTUD（路径 MTU 发现）需通过 TCP、IP 与 ICMP 协议协同实现。其核心依赖两项机制：一是避免源端分片，二是设置 IPv4 的 DF（不分片）标志 —— 后者的作用是阻止路径上的分片行为。当 TCP 分段因尺寸过大而无法通过某段链路时，
PMTUD 需依赖路径中路由器返回的 ICMP 错误消息进行调整。RFC 2923 中描述了对支持 PMTUD 的 TCP 实现的若干优化调整，旨在解决实际应用中遇到的问题。PLPMTUD（分组层路径 MTU 发现）是 PMTUD 的标准跟踪类（Standards Track）改进方案：
它放宽了对路径中 ICMP 支持的强制要求，在 ICMP 消息传输不一致的场景下能提升性能，同时仍保持 “避免源端分片” 的核心目标。建议 TCP 实现中纳入上述四份 RFC（注：结合上下文，指 RFC 1191、1122、2923、4821）中规定的所有机制。

TCP MSS 选项（Maximum Segment Size Option，最大分段大小选项）规定了接收方所能处理的数据包的大小上限（参见前文）。因此，若将 MSS 选项中的值设置得过小，会影响 PMTUD（路径 MTU 发现）或 PLPMTUD（分组层路径 MTU 发现）
探测更大路径 MTU 的能力。RFC 1191 讨论了这一问题的影响：许多早期 TCP 实现会将非本地目的地的 TCP MSS 固定设为 536 字节（对应 IPv4 中 576 字节的默认 MTU），而非按照建议的方式 —— 从直连接口的 MTU 中推导得出该值。

### 支持可变 MTU 值的接口

有效 MTU（最大传输单元）有时会发生变化，例如在使用可变压缩技术时 —— 如 RObust 报头压缩（ROHC）。TCP 协议实现往往倾向于通告尽可能大的 MSS（最大分段大小），以支持压缩载荷的最高效利用。但遗憾的是，
部分压缩方案偶尔需要传输完整报头（从而导致载荷变小），以同步端点压缩器 / 解压缩器的状态。若使用最大 MTU 来计算 MSS 选项中的通告值，TCP 重传可能会干扰压缩器的状态同步。

因此，当接口的有效 MTU 逐包变化时，TCP 协议实现应采用该接口的最小有效 MTU来计算 MSS 选项中的通告值（参见 SHLD-6 标准）。

### Nagle 算法

“纳格尔算法（Nagle algorithm）” 在 RFC 896 中被首次描述，并在 RFC 1122 中被推荐用于缓解早期出现的 “小包泛滥” 问题。该算法已在当前绝大多数 TCP 代码库中实现，部分实现存在细微差异（参见附录 A.3）。

若存在未确认数据（即发送方下一个要发送的字节序号 SND.NXT > 已发送但未确认的字节序号 SND.UNA），则发送方 TCP 端点会缓存所有用户数据（无论 PSH 标志位是否设置），直至未确认数据被接收方确认，
或 TCP 端点可发送一个满尺寸分段（即有效发送最大分段大小 Eff.snd.MSS 字节）。

TCP 协议实现应采用纳格尔算法来合并短分段（SHLD-7）。但必须提供一种机制，允许应用程序在单个连接上禁用纳格尔算法（MUST-17）。在所有情况下，数据发送还需遵守慢启动算法（slow start algorithm）施加的限制。

由于纳格尔算法与延迟确认（delayed acknowledgments）之间可能存在引发问题的交互，部分实现采用了纳格尔算法的细微变体（例如附录 A.3 中描述的版本）。

### IPV6 超大帧

为支持基于 IPv6 超大帧（IPv6 Jumbograms）的 TCP 传输，协议实现需能够发送超过 MSS 选项所能承载的 64KB 限制的 TCP 分段。RFC 2675 规定：当 MSS 值为 65535 字节时，应将其视为 “无限大”（infinity），实际 MSS 需通过路径 MTU 发现（Path MTU Discovery）机制确定。

对于无需接入 “MTU 大于 65575 字节的链路” 的 IPv6 节点，无需实现或理解 “超大载荷选项（Jumbo Payload Option）”；且当前的《IPv6 节点需求规范》（IPv6 Node Requirements）并未包含对超大帧的支持要求。


## 数据传输

连接建立后，数据通过分段（segment）交换实现通信。由于分段可能因错误（如校验和验证失败）或网络拥塞而丢失，TCP 协议采用重传（retransmission）机制确保每个分段的可靠交付。此外，受网络因素或 TCP 重传影响，可能会出现重复分段（duplicate segments）的情况。如 3.4 节 “序号（sequence numbers）” 部分所述，TCP 协议实现会对分段中的序号和确认号（acknowledgment numbers）执行特定校验，以验证其可接受性。

数据发送方通过变量SND.NXT记录下一个待使用的序号；数据接收方通过变量RCV.NXT记录下一个期望接收的序号；数据发送方还通过变量SND.UNA记录最早未被确认的序号。若数据流暂时空闲且所有已发送数据均已得到确认，则这三个变量的值将保持一致。

当发送方创建并传输一个分段时，会更新（推进）SND.NXT 的值；当接收方接受一个分段后，会更新（推进）RCV.NXT 并发送确认（acknowledgment）；当数据发送方收到确认后，会更新（推进）SND.UNA 的值。这些变量之间的差值反映了通信过程中的延迟情况；变量的更新幅度（推进量）等于分段中的数据长度，加上 SYN 或 FIN 标志位对应的序号偏移（注：SYN 和 FIN 标志位本身各占用 1 个序号）。需注意：一旦连接进入ESTABLISHED 状态（已建立状态） ，所有发送的分段都必须携带当前有效的确认信息。

用户发起的CLOSE 调用隐含 “推送（push）功能”（见 3.9.1 节）；同样，接收方收到含FIN 控制标志位的分段时，也会触发该推送功能。

### 超时重传

由于构成互联网络系统的网络存在差异性，且 TCP 连接的应用场景极为广泛，重传超时时间（RTO）必须动态确定。

RTO 的计算需遵循相关文档中规定的算法，包括用于 RTT（往返时间）采样的卡恩算法（Karn's Algorithm）（MUST-18 强制要求）。

RFC 793 中包含了一个早期的 RTO 计算流程示例，其基于 IEN 177 中提及的研究成果。该流程随后被 RFC 1122 中描述的算法取代，而 RFC 1122 中的算法又先后在 RFC 2988 和 RFC 6298 中得到更新。

RFC 1122 允许：若重传的数据包与原始数据包完全一致（这不仅意味着数据边界未发生变化，还要求所有头部字段均未修改），则可复用相同的 IPv4 标识字段（参见 RFC 1122 第 3.2.1.5 节）（MAY-4 可选要求）。此外，由于 IPv4 标识字段仅在数据报被分片时才有意义，
因此无论是否满足上述条件，该字段均可复用。TCP 实现不应以任何方式依赖此 IPv4 头部字段，也通常不应与此字段产生交互 —— 它既不是标识已发送段重复的合理方式，也不能用于识别接收段的重复。

### TCP 拥塞控制

TCP 拥塞控制是 TCP 协议的核心机制之一，其核心目标是在不引发网络拥塞的前提下，最大化利用网络带宽—— 通过动态调整发送方的数据包发送速率，避免因发送速率超过网络链路承载能力导致的数据包丢失、延迟增加等问题，同时实现网络资源的公平共享（多个 TCP 连接公平占用带宽）。

它与上一轮提到的 RTO（重传超时）紧密关联：拥塞控制决策（如是否增加发送速率）会参考 RTO 超时、数据包丢失等网络反馈，而 RTO 的动态调整也为拥塞状态判断提供了关键依据。

RFC 2914 阐述了拥塞控制对互联网的重要性。

RFC 1122 要求实现范・雅各布森（Van Jacobson）提出的拥塞控制算法 —— 慢启动（slow start）和拥塞避免（congestion avoidance），同时要求对同一数据段的连续重传超时时间（RTO）值执行指数退避（exponential backoff）。RFC 2581 提供了慢启动、拥塞避免的 IETF 标准轨道（Standards Track）描述，同时纳入了快速重传（fast retransmit）和快速恢复（fast recovery）机制。RFC 5681 是这些算法的当前最新描述，也是提供 TCP 拥塞控制指导原则的现行标准轨道规范。RFC 6298 规定了 RTO 值的指数退避逻辑，包括：在后续携带新数据的数据段被成功发送且未经过重传便得到确认前，需保留已退避后的 RTO 值。

为避免引发拥塞崩溃（congestion collapse），TCP 端点必须实现基础拥塞控制算法 —— 慢启动、拥塞避免，以及 RTO 指数退避（MUST-19 强制要求）。RFC 5681 和 RFC 6298 描述的基础算法属于 IETF 标准轨道，具有广泛适用性。此外，还存在多种其他适用且已被广泛使用的算法。许多 TCP 实现支持一组可配置在端点上使用的替代算法：只要这些替代算法符合 RFC 2914、RFC 5033 和 RFC 8961 中所述的 IETF 标准轨道 TCP 规范，端点可以实现此类替代算法（MAY-18 可选要求）。

显式拥塞通知（Explicit Congestion Notification, ECN）在 RFC 3168 中定义，是 IETF 标准轨道的增强机制，具有诸多优势。
TCP 端点应当实现 RFC 3168 中描述的 ECN 机制（SHLD-8 应当要求）。

### TCP 连接失败

TCP 端点对同一数据段的过度重传，表明远程主机或互联网络路径存在某种故障。该故障的持续时间可能较短，也可能较长。应采用以下流程处理数据段的过度重传问题（MUST-20）：

（1）存在两个阈值 R1 和 R2，用于衡量同一数据段已发生的重传量。R1 和 R2 可采用时间单位计量，或按重传次数计量（如需，可将当前重传超时时间（RTO）及相应退避值作为转换因子）；

（2）当同一数据段的传输次数达到或超过阈值 R1 时，向 IP 层传递否定性建议（参见3.3.1.4相关章节），以触发死网关诊断。

（3）当同一数据段的传输次数达到阈值 R2（R2 大于 R1）时，关闭该连接；

（4）应用程序必须能够为特定连接设置 R2 的值（MUST-21）。例如，交互式应用程序可将 R2 设为「无限大」，由用户控制断开连接的时机；

（5）当达到阈值 R1 且未达到 R2 时，TCP 实现建议将传输问题告知应用程序（除非应用程序已禁用此类信息通知；参见「异步报告」章节（3.9.1.8 节））（SHLD-9）。例如，这能让远程登录应用程序向用户发出通知；

在当前重传超时时间（RTO）下，阈值 R1 建议至少对应 3 次重传（SHLD-10）。阈值 R2 应至少对应 100 秒（SHLD-11）；

TCP 连接建立尝试可能会失败，原因包括 SYN 段的过度重传、收到 RST 段或 ICMP 端口不可达报文。SYN 段的重传应按前所述的数据段重传通用流程处理，包括向应用层发送通知。

但需注意，SYN 段与数据段的 R1 和 R2 阈值可设置为不同值。具体而言，SYN 段的 R2 阈值必须设置得足够大，以确保该段的重传时长至少达到 3 分钟（MUST-23）。当然，应用程序也可提前关闭连接（即放弃连接建立尝试）。

### TCP 保活

若 TCP 连接在一段较长时间内未收到任何入站数据段，且无新数据或未确认数据需发送，则该连接被称为**空闲连接**。

实现者可在其 TCP 实现中包含「保活机制」（MAY-5），尽管该做法尚未被普遍接受。不过，部分 TCP 实现已纳入保活机制。为确认空闲连接仍处于活跃状态，这些实现会发送探测数据段，旨在触发 TCP 对端的响应。
此类数据段通常满足 SEG.SEQ = SND.NXT - 1，可能包含一个无效字节的数据，也可能不包含。若 TCP 实现包含保活机制，则应用程序必须能够为每个 TCP 连接启用或禁用该机制（MUST-24），且保活机制的默认状态必须为关闭（MUST-25）。

保活报文仅能在以下条件下发送：无已发送但未确认的数据，且在某一时间段内未收到该连接的任何数据报文或确认报文（MUST-26）。该时间间隔必须可配置（MUST-27），且默认值必须不小于两小时（MUST-28）。

必须牢记的是，TCP 并不可靠地传输不含数据的 ACK 报文段。因此，若实现了保活机制，则不得将单个探测报文未收到响应的情况认定为连接失效（MUST-29）。

TCP 实现应发送不含数据的保活数据段（SHLD-12），不过，为兼容存在缺陷的 TCP 实现，可将其配置为发送包含一个无效字节的保活数据段（MAY-6）。

### 紧急消息传输

由于实现差异及中间设备交互问题，新应用程序不应采用 TCP 紧急机制（SHLD-13）。但 TCP 实现仍必须包含对该紧急机制的支持（MUST-30）。关于部分 TCP 实现如何解析紧急指针的相关信息，可参阅 RFC 6093 [39]。

TCP 紧急机制的目标是：允许发送方用户触发接收方用户接收特定紧急数据，并使接收方 TCP 端点能够向接收方用户告知 —— 当前已知的所有紧急数据均已被用户接收完毕。

该机制允许在数据流中指定一个点位，作为紧急信息的结束位置。只要该点位超出接收方 TCP 端点的当前接收序列号（RCV.NXT），TCP 实现就必须通知用户进入「紧急模式」；当接收序列号追赶上紧急指针时，
TCP 实现必须通知用户进入「正常模式」。若用户处于「紧急模式」期间紧急指针被更新，该更新对用户不可见。

该机制通过在所有传输的数据段中携带紧急字段实现。URG 控制标志位表示该紧急字段有效，且必须将其与数据段的序列号相加，以得到紧急指针。若该标志位未置位，则表示当前无未处理的紧急数据。

要发送紧急指示，用户必须同时发送至少一个数据字节。若发送方用户还指定了推送（Push）操作，则紧急信息向目标进程的及时交付会得到增强。需注意，由于紧急指针的变更与发送方应用程序写入的数据相关联，
因此紧急指针在序列号空间中不得「后退」；但 TCP 接收方应能耐受无效的紧急指针值（具备鲁棒性）。

TCP 实现必须支持任意长度的紧急数据序列（MUST-31）[19]。

紧急指针必须指向紧急数据之后紧邻字节的序列号（MUST-62）。

TCP 实现必须（MUST-32）在以下两种场景下异步通知应用层：一是收到紧急指针且此前无未处理的紧急数据时；二是紧急指针在数据流中向前推进时。TCP 实现还必须（MUST-33）提供一种方式，
让应用层能够获知连接中仍有待读取的紧急数据量，或至少能判断是否仍有更多紧急数据待读取 [19]。

### 窗口管理


